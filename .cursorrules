# Savvy Funnel Analytics Dashboard - Project Instructions

## Project Context

You are working on the **Savvy Funnel Analytics Dashboard**, a Next.js 14 application that replaces Tableau for funnel analytics. The dashboard connects to BigQuery and visualizes data from the `vw_funnel_master` view.

**Repository**: https://github.com/russellmoss/dashboard  
**Current Status**: All core phases complete (1-12), Full Funnel View, SGA Hub & SGA Management, Drill-Down, Saved Reports, Password features (forgot/reset/change), rate limiting (Upstash)

---

## ‚ö†Ô∏è VERIFICATION PROTOCOL - MANDATORY

### Before Making ANY Calculation Changes

1. **READ `docs/GROUND-TRUTH.md` FIRST** - Contains verified values with cohort maturity tiers
2. **Use TIER 1 cohorts (Q1/Q2 2025) for validation** - These are fully baked and immutable
3. **Never validate calculation logic with Q4 2025** - Cohort is immature, rates WILL change

### Cohort Maturity Quick Reference

| Cohort | Status | Use For |
|--------|--------|---------|
| Q1 2025 | üü¢ STABLE (288 days) | Strict validation - values MUST match |
| Q2 2025 | üü¢ STABLE (197 days) | Secondary validation |
| Q3 2025 | üü° MATURING (105 days) | Directional checks only |
| Q4 2025 | üî¥ CURRENT (13 days) | UI/filter testing only |

### Q1 2025 Ground Truth (PRIMARY - Use This)

| Metric | Expected | Tolerance |
|--------|----------|-----------|
| SQLs | **123** | ¬±0 |
| SQOs | **96** | ¬±0 |
| Joined | **12** | ¬±0 |
| Contacted‚ÜíMQL | **4.94%** (314/6,360) | ¬±0.1% |
| MQL‚ÜíSQL | **27.70%** (123/444) | ¬±0.1% |
| SQL‚ÜíSQO | **70.83%** (85/120) | ¬±0.1% |
| SQO‚ÜíJoined | **12.20%** (10/82) | ¬±0.1% |

### Q2 2025 Ground Truth (SECONDARY)

| Metric | Expected | Tolerance |
|--------|----------|-----------|
| SQLs | **155** | ¬±0 |
| SQOs | **110** | ¬±0 |
| Joined | **13** | ¬±0 |
| Contacted‚ÜíMQL | **4.63%** (315/6,809) | ¬±0.1% |
| MQL‚ÜíSQL | **37.93%** (154/406) | ¬±0.1% |
| SQL‚ÜíSQO | **68.63%** (105/153) | ¬±0.1% |
| SQO‚ÜíJoined | **13.79%** (12/87) | ¬±0.1% |

### Verification Workflow

```
1. Read docs/GROUND-TRUTH.md for expected values
2. Make your code changes
3. Test with Q1 2025 filters (Jan 1 - Mar 31, 2025)
4. Compare results to TIER 1 ground truth
5. If mismatch ‚Üí STOP and investigate (do NOT proceed)
6. If match ‚Üí Test with Q4 2025 for sanity check
7. Document any findings
```

### Files That REQUIRE Verification After Changes

If you modify ANY of these files, you MUST verify against Q1/Q2 2025 ground truth:
- `src/lib/queries/conversion-rates.ts`
- `src/lib/queries/funnel-metrics.ts`
- `src/lib/queries/source-performance.ts`
- `src/app/api/dashboard/conversion-rates/route.ts`
- `src/app/api/dashboard/funnel-metrics/route.ts`
- `vw_funnel_master.sql`

### MCP Salesforce Verification (When Needed)

Use MCP to query Salesforce directly for fresh validation:

**SQOs:**
```sql
SELECT COUNT(Id) FROM Opportunity WHERE RecordType.Name = 'Recruiting' AND SQL__c = 'Yes' AND Date_Became_SQO__c >= [START] AND Date_Became_SQO__c <= [END]
```

**Joined:**
```sql
SELECT COUNT(Id) FROM Opportunity WHERE RecordType.Name = 'Recruiting' AND StageName = 'Joined' AND Advisor_Join_Date__c >= [START] AND Advisor_Join_Date__c <= [END]
```

**SQLs:**
```sql
SELECT COUNT(Id) FROM Lead WHERE IsConverted = true AND ConvertedDate >= [START] AND ConvertedDate <= [END]
```

---

## Key Principles

1. **Data Source**: All queries must use the `vw_funnel_master` view (`savvy-gtm-analytics.Tableau_Views.vw_funnel_master`)
2. **Security**: Always use BigQuery parameterized queries (`@paramName` syntax) - never string interpolation
3. **Type Safety**: Use TypeScript types from `src/types/` - maintain type consistency
4. **Date Dimensions & Flags**: Each conversion rate uses specific cohort dates and pre-calculated flags:
   | Conversion | Cohort Date | Numerator Flag | Denominator Flag |
   |------------|-------------|----------------|------------------|
   | Contacted‚ÜíMQL | `stage_entered_contacting__c` | `contacted_to_mql_progression` | `eligible_for_contacted_conversions_30d` |
   | MQL‚ÜíSQL | `mql_stage_entered_ts` | `mql_to_sql_progression` | `eligible_for_mql_conversions` |
   | SQL‚ÜíSQO | `converted_date_raw` | `sql_to_sqo_progression` | `eligible_for_sql_conversions` |
   | SQO‚ÜíJoined | `Date_Became_SQO__c` | `sqo_to_joined_progression` | `eligible_for_sqo_conversions` |
5. **Deduplication**: Use `is_sqo_unique` and `is_joined_unique` for opportunity-level metrics
6. **Record Type**: SQO calculations must filter by `recordtypeid = '012Dn000000mrO3IAI'` (Recruiting)
7. **SGA Attribution for Opportunity Metrics**: 
   - **Lead-level metrics** (Prospects, Contacted, MQLs, SQLs): Use `SGA_Owner_Name__c` only
   - **Opportunity-level metrics** (SQOs, Joined, AUM): Check BOTH `SGA_Owner_Name__c` AND `Opp_SGA_Name__c`
   - **Critical**: `Opp_SGA_Name__c` may contain a Salesforce User ID (e.g., `005VS000000QHlBYAW`) instead of a name
   - **Solution**: Join with User table to resolve IDs: `LEFT JOIN \`savvy-gtm-analytics.SavvyGTMData.User\` sga_user ON v.Opp_SGA_Name__c = sga_user.Id`
   - **Filter Pattern**: `(v.SGA_Owner_Name__c = @sga OR v.Opp_SGA_Name__c = @sga OR COALESCE(sga_user.Name, v.Opp_SGA_Name__c) = @sga)`

## Architecture Patterns

### Query Functions (`src/lib/queries/`)
- Use `runQuery<T>()` from `src/lib/bigquery.ts`
- Always use parameterized queries with `@paramName` syntax
- Return typed results using interfaces from `src/types/bigquery-raw.ts`
- Transform raw results to dashboard types in the query function

### API Routes (`src/app/api/dashboard/`)
- Use `getServerSession()` for authentication
- Extract permissions via `getSessionPermissions(session)` from `@/types/auth` (NO database query)
- Return `NextResponse.json()` with proper error handling
- Log errors but don't expose sensitive details

---

## Authentication & Permissions Pattern (CRITICAL)

### ‚ùå NEVER DO THIS (causes unnecessary database queries):
```typescript
import { getUserPermissions } from '@/lib/permissions';

const session = await getServerSession(authOptions);
const permissions = await getUserPermissions(session.user.email); // BAD - queries DB!

// Also avoid querying User table just for user ID:
const user = await prisma.user.findUnique({ 
  where: { email: session.user.email },
  select: { id: true }
}); // BAD - unnecessary DB query!
```

### ‚úÖ ALWAYS DO THIS (zero database queries):
```typescript
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { getSessionPermissions } from '@/types/auth';

const session = await getServerSession(authOptions);
const permissions = getSessionPermissions(session); // GOOD - no DB query!

if (!permissions) {
  return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
}

// User ID is available directly from permissions:
const userId = permissions.userId; // GOOD - no DB query!
```

### Why This Matters
- The session callback in `authOptions` already computes permissions from JWT data
- `getUserPermissions(email)` ALWAYS queries the database, even when data exists in session
- `getSessionPermissions(session)` extracts pre-computed permissions with zero DB queries
- User ID (`permissions.userId`) is stored in the JWT - no need to query User table
- **Impact**: Eliminating these queries reduces 2-6 DB queries per API request to zero

### Available Permission Fields
```typescript
interface UserPermissions {
  userId: string;                    // User's database ID
  role: UserRole;                    // admin, manager, sga, sgm, recruiter, viewer, revops_admin
  allowedPages: number[];            // Page IDs user can access
  canExport: boolean;                // Can export data
  canManageUsers: boolean;           // Can manage user accounts
  canManageRequests: boolean;        // Can manage dashboard requests (revops_admin only)
  sgaFilter: string | null;          // SGA name filter (for sga role)
  sgmFilter: string | null;          // SGM name filter (for sgm role)
  recruiterFilter: string | null;    // External agency filter (for recruiter role)
}
```

### When Creating New API Routes
1. Import `getSessionPermissions` from `@/types/auth`
2. Call `getServerSession(authOptions)` once
3. Extract permissions with `getSessionPermissions(session)`
4. Use `permissions.userId` instead of querying the User table
5. Check `permissions.role` or specific permission flags for authorization
6. For recruiter blocking, use `forbidRecruiter(permissions)` from `@/lib/api-authz`

### Exception: When to Use getUserPermissions()
Only use `getUserPermissions(email)` when you need **fresh data from the database** after a role change. This is rare - typically only in:
- Admin user management (after updating a user's role)
- The `/api/auth/permissions` route (legacy, should be migrated)

---

### Components (`src/components/dashboard/`)
- Use client components (`'use client'`) for interactivity
- Fetch data via `dashboardApi` from `src/lib/api-client.ts`
- Handle loading and error states
- Use Tremor components for tables/cards, Recharts for trend charts

### Date Filtering
- Use `buildDateRangeFromFilters()` from `src/lib/utils/date-helpers.ts`
- Apply date filters to the specific date field for each metric
- For trend charts, expand to full year: `YYYY-01-01` to `YYYY-12-31`

### DATE vs TIMESTAMP Type Handling in Period Comparisons (CRITICAL)

**‚ö†Ô∏è CRITICAL**: When comparing DATE and TIMESTAMP fields in period comparison queries, you MUST ensure type consistency to avoid BigQuery type mismatch errors.

**Problem**: BigQuery DATE and TIMESTAMP are incompatible types. Comparing `DATE(v.field) >= TIMESTAMP(...)` or `TIMESTAMP(v.field) >= DATE(...)` causes "No matching signature for operator >= for argument types: DATE, TIMESTAMP" errors.

**Solution**: Always use `DATE()` conversion for both sides of comparisons in period comparisons, even for TIMESTAMP fields.

**Pattern for Period Comparisons (`compilePeriodComparison` in `query-compiler.ts`):**

1. **WHERE Clause Filters**: Always wrap both the field and date expressions in `DATE()`
   ```sql
   -- CORRECT: Both sides are DATE
   AND DATE(v.mql_stage_entered_ts) >= DATE(DATE_TRUNC(CURRENT_DATE(), QUARTER))
   AND DATE(v.mql_stage_entered_ts) <= DATE(CURRENT_DATE())
   
   -- WRONG: Mixing DATE and TIMESTAMP
   AND TIMESTAMP(v.mql_stage_entered_ts) >= DATE_TRUNC(CURRENT_DATE(), QUARTER)
   ```

2. **Metric SQL Replacement**: Convert `TIMESTAMP(v.field)` to `DATE(v.field)` FIRST, then replace placeholders
   ```typescript
   // Step 1: Convert field to DATE
   metricSql = metricSql.replace(
     /TIMESTAMP\s*\(\s*v\.(\w+)\s*\)/g,
     `DATE(v.$1)`
   );
   
   // Step 2: Replace TIMESTAMP(@startDate) with DATE(date_expression)
   metricSql = metricSql.replace(
     /TIMESTAMP\s*\(\s*@startDate\s*\)/g,
     `DATE(${dateExpression})`
   );
   ```

3. **Date Expression Wrapping**: Wrap preset date expressions in `DATE()` even if they already return DATE
   ```typescript
   // CORRECT: Explicit DATE wrapping ensures type consistency
   currentMetricSql = currentMetricSql.replace(
     /TIMESTAMP\s*\(\s*@startDate\s*\)/g,
     `DATE(DATE_TRUNC(CURRENT_DATE(), QUARTER))`
   );
   
   // WRONG: Leaving DATE expression unwrapped can cause type inference issues
   currentMetricSql = currentMetricSql.replace(
     /TIMESTAMP\s*\(\s*@startDate\s*\)/g,
     `DATE_TRUNC(CURRENT_DATE(), QUARTER)`  // Missing DATE() wrapper
   );
   ```

**Why This Matters:**
- MQLs use `mql_stage_entered_ts` (TIMESTAMP field) but must be compared as DATE for period comparisons
- SQLs use `converted_date_raw` (DATE field) and also need DATE() wrapping for consistency
- The working BigQuery pattern is: `DATE(timestamp_field) BETWEEN start_date AND end_date` where both sides are DATE

**Files to Update When Adding New Metrics:**
- `src/lib/semantic-layer/query-compiler.ts` - `compilePeriodComparison` function
- Ensure both `currentPeriodFilter` and `previousPeriodFilter` use `DATE(v.${dateField})`
- Ensure metric SQL replacement converts `TIMESTAMP(v.field)` to `DATE(v.field)` before replacing placeholders

**Verification:**
- Test period comparisons for metrics with TIMESTAMP fields (MQLs, SQOs, Prospects, Contacted)
- Test period comparisons for metrics with DATE fields (SQLs, Initial Calls, Qualification Calls)
- Check BigQuery error logs for "No matching signature" errors - indicates type mismatch

**Reference Fixes:**
- **MQL Period Comparison (Fixed: January 16, 2026)**: Converted `TIMESTAMP(v.mql_stage_entered_ts)` to `DATE(v.mql_stage_entered_ts)` in both WHERE clause and metric SQL, wrapped all date expressions in `DATE()`
- **SQL Period Comparison (Fixed: January 16, 2026)**: Simplified `last_quarter` endDateSql to pure DATE expression, ensured `DATE(v.converted_date_raw)` comparisons throughout

## Caching Strategy

This project uses Next.js `unstable_cache()` with tag-based invalidation for BigQuery API routes.

### How to Cache New Query Functions

1. Import the cache utilities:
```typescript
   import { cachedQuery, CACHE_TAGS } from '@/lib/cache';
```

2. Wrap query functions using this pattern:
```typescript
   // Internal function (not exported)
   const _getMyData = async (filters: MyFilters): Promise => {
     // ... query logic
   };

   // Export cached version
   export const getMyData = cachedQuery(
     _getMyData,
     'getMyData',           // Explicit key name (required)
     CACHE_TAGS.DASHBOARD   // Or CACHE_TAGS.SGA_HUB
   );
```

### Cache Tags
- `CACHE_TAGS.DASHBOARD` ‚Äî Main dashboard routes (funnel-metrics, conversion-rates, etc.)
- `CACHE_TAGS.SGA_HUB` ‚Äî SGA Hub routes (weekly-actuals, quarterly-progress, etc.)

### TTL Values
- `DEFAULT_CACHE_TTL` (12 hours) ‚Äî Standard routes
- `DETAIL_RECORDS_TTL` (6 hours) ‚Äî Large result sets only

### Do NOT Cache
- `agent-query.ts` ‚Äî AI agent dynamic SQL exploration (must always be fresh)
- `export-records.ts` ‚Äî Export operations
- Any user-specific or real-time data

### Cache Invalidation
- Automatic daily: 12 AM EST (after 11:30 PM daily transfer) - Sun-Thu, Sat
- Automatic Fridays: 3pm, 4pm, 6pm EST (after hourly transfers)
- Manual: Admin refresh button in DataFreshnessIndicator
- API: `POST /api/admin/refresh-cache` (admin only)

### API Routes
- Do NOT use `export const dynamic = 'force-dynamic'` for **cached** dashboard/sga-hub routes ‚Äî caching is handled at query level
- **Exception**: Auth routes (`/api/auth/forgot-password`, `/api/auth/reset-password`, `/api/users/me/change-password`) use `force-dynamic`; they are not cached
- Do NOT set manual `Cache-Control` headers ‚Äî handled by `unstable_cache()`

## Key Files Reference

### Core Query Logic
- `src/lib/queries/conversion-rates.ts` - Scorecard and trend chart queries
- `src/lib/queries/funnel-metrics.ts` - Volume metrics (SQLs, SQOs, Joined, AUM)
- `src/lib/queries/source-performance.ts` - Channel and source breakdowns

### Configuration
- `src/config/constants.ts` - Table names, record types, constants
- `src/types/dashboard.ts` - Dashboard data types
- `src/types/bigquery-raw.ts` - Raw BigQuery result types

### Components
- `src/components/dashboard/ConversionTrendChart.tsx` - Trend chart (uses Recharts)
- `src/components/dashboard/ConversionRateCards.tsx` - Scorecard cards
- `src/app/dashboard/page.tsx` - Main dashboard with data fetching

### Documentation
- `docs/GROUND-TRUTH.md` - **Verified values with cohort maturity tiers (READ FIRST)**
- `docs/GLOSSARY.md` - Business definitions and terminology
- `docs/CALCULATIONS.md` - Detailed calculation formulas (period vs cohort modes)
- `docs/FILTER-MATRIX.md` - Filter application by metric type
- `conversion_rate_explanation.md` - Cohort mode explanation
- `vw_funnel_master.sql` - BigQuery view definition with all flags
- `docs/password-investigation.md` - Auth overview, password feature design
- `password-implementation-plan.md` - Forgot/reset/change password implementation plan

## Password Features (Auth / Forgot / Reset / Change)

### Overview

- **Forgot password**: Login page ‚Üí ‚ÄúForgot password?‚Äù ‚Üí modal ‚Üí enter email ‚Üí reset link sent via SendGrid.
- **Reset password**: `/reset-password?token=...` (link from email) ‚Üí set new password ‚Üí redirect to login.
- **Change password**: Dashboard ‚Üí Settings ‚Üí ‚ÄúMy Account‚Äù ‚Üí ‚ÄúChange My Password‚Äù (all authenticated users). User Management (admin-only) remains below.

### Key Files

| File | Purpose |
|------|---------|
| `src/lib/email.ts` | SendGrid: `sendPasswordResetEmail` |
| `src/lib/rate-limit.ts` | Upstash limiters (forgot, reset, login), `checkRateLimit`, lazy init |
| `src/lib/password-utils.ts` | `validatePassword`, `hashPassword`, `verifyPassword`, reset token create/validate/mark-used |
| `src/app/api/auth/forgot-password/route.ts` | POST; rate-limited; no email enumeration |
| `src/app/api/auth/reset-password/route.ts` | GET validate token, POST reset; rate-limited |
| `src/app/api/users/me/change-password/route.ts` | POST; requires session; current + new password |
| `src/app/reset-password/page.tsx` | Token-based reset UI (dark theme) |
| `src/app/login/page.tsx` | Forgot password modal (dark theme) |
| `src/components/settings/ChangePasswordModal.tsx` | Change password modal |
| `src/app/dashboard/settings/page.tsx` | My Account + Change Password; User Management only if `canManageUsers` |
| `src/lib/auth.ts` | NextAuth config; **login rate limiting** in `authorize` |
| `prisma/schema.prisma` | `PasswordResetToken` model, `User.passwordResetTokens` |

### Conventions (Use in New Auth Code)

- **bcryptjs** only (not `bcrypt`). Hash/compare via `password-utils`.
- **Prisma**: `import { prisma } from '@/lib/prisma'`.
- **New auth API routes**: `export const dynamic = 'force-dynamic'` (these are **not** cached; caching rules apply to dashboard/sga-hub etc.).
- **Login page / reset page / forgot modal**: Dark theme; match existing styles.

### Rate Limiting (Upstash Redis)

- **Library**: `@upstash/ratelimit`, `@upstash/redis`. Limiters in `src/lib/rate-limit.ts`.
- **Lazy init**: Redis and limiters created only when `UPSTASH_REDIS_REST_URL` and `UPSTASH_REDIS_REST_TOKEN` are set. No init at import.
- **Getters**: Use `getForgotPasswordLimiter()`, `getResetPasswordLimiter()`, `getLoginLimiter()` (not raw exports). Pass to `checkRateLimit(limiter, identifier)`.
- **Graceful degradation**: If Upstash env vars missing, `checkRateLimit` logs a warning and returns `{ success: true }` (no blocking).
- **Limits**: Forgot 3/h per email; Reset 5/h per token; Login 5 per 15 min per email. Login returns `null` (same as wrong password) when limited‚Äîno 429.

### Verifying Upstash

- Env vars set ‚Üí no ‚ÄúRate limiting not configured‚Äù log when hitting forgot/reset/login.
- Forgot: 4th request same email in 1 h ‚Üí **429**.
- Reset: 6th attempt same token in 1 h ‚Üí **429**.
- Login: 6+ wrong passwords same email ‚Üí same ‚ÄúInvalid email or password‚Äù; server log ‚ÄúRate limit exceeded for login‚Äù.

### Password Rules

- Min **8 characters** (`validatePassword` in `password-utils`).
- Reset tokens: **1 h** expiry, **single-use**; stored in `PasswordResetToken`.

### Email

- **SendGrid**: `SENDGRID_API_KEY`, `EMAIL_FROM`. `EMAIL_FROM` must be a verified sender.
- **Reset link base**: `NEXT_PUBLIC_APP_URL` (default `http://localhost:3000`).
- UI and email copy warn users to check **spam** when using personal Gmail as `EMAIL_FROM`.

### Middleware

- `/reset-password` and `/api/auth/forgot-password`, `/api/auth/reset-password` are **not** protected by dashboard middleware; they stay public.

## Development Guidelines

### When Working with Conversion Rates

1. **Read Ground Truth First**: Check `docs/GROUND-TRUTH.md` for expected values and cohort maturity
2. **Use TIER 1 for Validation**: Test with Q1 2025 (primary) or Q2 2025 (secondary)
3. **Use Pre-calculated Flags**: Always use `*_progression` for numerators, `eligible_for_*` for denominators
4. **Understand Cohort Mode**: Denominators only include RESOLVED records (converted OR closed)
5. **Never Restrict Cross-Period**: A Q4 SQL can become Q1 SQO - that's valid cohort behavior
6. **Verify After Changes**: Run BigQuery verification query against Q1/Q2 2025

### When Adding Features

1. **Follow Existing Patterns**: Match the structure of existing query functions and components
2. **Type Safety**: Define types in `src/types/` before implementing
3. **Error Handling**: Always handle errors gracefully with user-friendly messages
4. **Testing**: Test against known Q4 2025 values when possible

### When Debugging

1. **Check BigQuery View**: Verify logic against `vw_funnel_master.sql` structure
2. **Use Logger**: Use `logger.debug()` from `@/lib/logger` to track data flow (not console.log)
3. **Test Queries**: Test BigQuery queries directly before implementing in code
4. **Compare Scorecard**: If chart values differ, compare with scorecard calculation
5. **Check Documentation**: Refer to `docs/CALCULATIONS.md` and `docs/GLOSSARY.md` for definitions

## Important Constants

- **Recruiting Record Type**: `'012Dn000000mrO3IAI'`
- **Full Table**: `'savvy-gtm-analytics.Tableau_Views.vw_funnel_master'`
- **Mapping Table**: `'savvy-gtm-analytics.SavvyGTMData.new_mapping'`
- **Forecast Table**: `'savvy-gtm-analytics.SavvyGTMData.q4_2025_forecast'`

## Verification Values - TIERED APPROACH

### üü¢ TIER 1: Q1 2025 (STABLE - PRIMARY VALIDATION)

**Use for**: Strict validation of calculation logic  
**Status**: Fully baked (288 days) - Values are IMMUTABLE

| Metric | Expected |
|--------|----------|
| SQLs | 123 |
| SQOs | 96 |
| Joined | 12 |
| Contacted‚ÜíMQL | 4.94% (314/6,360) |
| MQL‚ÜíSQL | 27.70% (123/444) |
| SQL‚ÜíSQO | 70.83% (85/120) |
| SQO‚ÜíJoined | 12.20% (10/82) |

### üü¢ TIER 1: Q2 2025 (STABLE - SECONDARY VALIDATION)

**Use for**: Additional validation when needed  
**Status**: Fully baked (197 days) - Values are IMMUTABLE

| Metric | Expected |
|--------|----------|
| SQLs | 155 |
| SQOs | 110 |
| Joined | 13 |
| Contacted‚ÜíMQL | 4.63% (315/6,809) |
| MQL‚ÜíSQL | 37.93% (154/406) |
| SQL‚ÜíSQO | 68.63% (105/153) |
| SQO‚ÜíJoined | 13.79% (12/87) |

### üü° TIER 2: Q3 2025 (MATURING)

**Use for**: Directional validation  
**Status**: Mostly stable - SQO‚ÜíJoined may increase

| Metric | Expected |
|--------|----------|
| SQLs | 221 |
| SQOs | 133 |
| Joined | 15+ (may increase) |
| SQL‚ÜíSQO | ~67.8% |
| SQO‚ÜíJoined | ~17.5% (may increase to ~20%) |

### üî¥ TIER 3: Q4 2025 (CURRENT - SANITY CHECK ONLY)

**Use for**: UI testing, filter testing, sanity checks  
**Status**: IMMATURE - Rates WILL change significantly

| Metric | Value (as of Jan 13, 2026) | Notes |
|--------|---------------------------|-------|
| SQLs | 193 | Volume is stable |
| SQOs | 144 | Volume is stable |
| Joined | 17 | Will increase |
| SQO‚ÜíJoined | ~10% | Expect 15-20% when mature |

‚ö†Ô∏è **NEVER fail a build because Q4 2025 SQO‚ÜíJoined is "low"** - it hasn't baked yet!

## Code Style

- Use TypeScript strict mode
- Prefer async/await over promises
- Use descriptive variable names
- Add comments for complex logic
- Follow Next.js 14 App Router patterns
- Use Tailwind CSS for styling

## When Making Changes

1. **Read Related Files**: Understand the full context before changing
2. **Maintain Consistency**: Keep patterns consistent with existing code
3. **Update Types**: Update TypeScript types if data structures change
4. **Test Locally**: Run `npm run dev` and test changes
5. **Document Changes**: Update relevant documentation if needed

## Priority Focus Areas

1. **Maintain Data Accuracy**: Ensure all metrics match BigQuery view calculations
2. **Performance**: Optimize queries and add caching where appropriate
3. **User Experience**: Improve error messages and loading states
4. **Documentation**: Keep `docs/GLOSSARY.md`, `docs/CALCULATIONS.md`, and `docs/FILTER-MATRIX.md` updated

## SGA Attribution - CRITICAL PATTERN

### Opportunity-Level SGA Attribution (SQOs, Joined, AUM)

**‚ö†Ô∏è CRITICAL**: When filtering opportunity-level metrics (SQOs, Joined, AUM) by SGA, you MUST check both lead-level and opportunity-level SGA fields, and resolve User IDs to names.

**The Problem:**
- `Opp_SGA_Name__c` in `vw_funnel_master` may contain either:
  - A name string (e.g., "Perry Kalmeta") 
  - A Salesforce User ID (e.g., `005VS000000QHlBYAW`)
- When it contains an ID, filtering by name fails because `'005VS000000QHlBYAW' != 'Perry Kalmeta'`
- This causes SQOs to be excluded from results even though they should be included

**The Solution:**
1. **Join with User table** to resolve IDs to names:
   ```sql
   LEFT JOIN `savvy-gtm-analytics.SavvyGTMData.User` sga_user
     ON v.Opp_SGA_Name__c = sga_user.Id
   ```

2. **Check all three conditions** in your WHERE clause:
   ```sql
   WHERE (v.SGA_Owner_Name__c = @sgaName                    -- Lead-level SGA
       OR v.Opp_SGA_Name__c = @sgaName                      -- Opp SGA (if it's already a name)
       OR COALESCE(sga_user.Name, v.Opp_SGA_Name__c) = @sgaName)  -- Opp SGA (if it's an ID, resolve it)
   ```

**When to Apply:**
- ‚úÖ **Opportunity-level metrics**: SQOs, Joined, AUM, Signed
- ‚ùå **Lead-level metrics**: Prospects, Contacted, MQLs, SQLs (use `SGA_Owner_Name__c` only)

**Files That Must Follow This Pattern:**
- `src/lib/queries/funnel-metrics.ts` - ‚úÖ Fixed
- `src/lib/queries/quarterly-progress.ts` - ‚úÖ Fixed
- `src/lib/queries/drill-down.ts` - ‚úÖ Fixed
- `src/lib/queries/weekly-actuals.ts` - ‚úÖ Fixed
- `src/lib/semantic-layer/query-compiler.ts` - ‚úÖ Fixed
- Any new queries that filter opportunity-level metrics by SGA

**Example: Missing SQO Issue**
- **Scenario**: Perry Kalmeta has 5 SQOs in Q4 2025, but dashboard shows only 4
- **Root Cause**: Shang Chou opportunity has `Opp_SGA_Name__c = '005VS000000QHlBYAW'` (User ID) instead of "Perry Kalmeta"
- **Fix**: Added User table join and `COALESCE(sga_user.Name, v.Opp_SGA_Name__c)` check
- **Result**: All 5 SQOs now appear correctly

**Verification:**
- Test with SGAs who have opportunities where `Opp_SGA_Name__c` contains a User ID
- Query BigQuery directly: `SELECT SGA__c FROM Opportunity WHERE Id = '...'` - if it's an ID (starts with `005`), it needs resolution

## Questions to Ask Before Making Changes

- Does this match the `vw_funnel_master` view logic?
- Are we using the correct date field for this metric?
- Are we properly deduplicating opportunity-level metrics?
- Are we filtering by the correct record type for SQO calculations?
- Does this maintain consistency with the scorecard calculations?

## Common Pitfalls - AVOID THESE

### ‚ùå Using Wrong Deduplication Field
- **WRONG**: `COUNT(*) WHERE is_sqo = 1`
- **RIGHT**: `COUNT(*) WHERE is_sqo_unique = 1`
- **WHY**: Multiple leads can convert to one opportunity. Use `is_sqo_unique` for volume counts, `is_sqo` for progression flags.

### ‚ùå Missing Record Type Filter for SQOs
- **WRONG**: `WHERE is_sqo_unique = 1`
- **RIGHT**: `WHERE is_sqo_unique = 1 AND recordtypeid = '012Dn000000mrO3IAI'`
- **WHY**: Re-engagement opportunities have different record type. SQO/Joined metrics only count Recruiting opportunities.

### ‚ùå Using Wrong Date Field for Trend Grouping
- **WRONG**: Grouping numerator and denominator by different dates without proper joining
- **RIGHT**: Both must use same date field OR be properly joined with period alignment
- **WHY**: Mismatched periods give nonsensical rates. Period mode requires entry AND resolution in same period.

### ‚ùå Cohort Restrictions on Conversions
- **WRONG**: Only counting conversions where both dates are in same period
- **RIGHT**: Count all conversions where the ACTION date is in period (cohort mode allows cross-period conversions)
- **WHY**: A Q3 SQL can become a Q4 SQO - that's a valid Q4 conversion in cohort mode.

### ‚ùå Confusing SQL__c Field
- **WRONG**: Assuming `SQL__c` field means SQL status
- **RIGHT**: `SQL__c = 'Yes'` actually means SQO status (legacy naming)
- **WHY**: This is a Salesforce legacy naming issue. Always check the value, not the field name.

### ‚ùå Using Wrong SGA Field for Opportunity Metrics
- **WRONG**: Using only `SGA_Owner_Name__c` for opportunity metrics (SQOs, Joined, AUM)
- **WRONG**: Using `Opp_SGA_Name__c = @sgaName` without User table join when `Opp_SGA_Name__c` contains a User ID
- **RIGHT**: For opportunity-level metrics, check BOTH `SGA_Owner_Name__c` AND `Opp_SGA_Name__c` (with User table join to resolve IDs)
- **WHY**: 
  - SQOs can be attributed via lead-level SGA (`SGA_Owner_Name__c`) OR opportunity-level SGA (`Opp_SGA_Name__c`)
  - `Opp_SGA_Name__c` may contain either a name (string) OR a Salesforce User ID (e.g., `005VS000000QHlBYAW`)
  - When `Opp_SGA_Name__c` contains an ID, you MUST join with the User table to resolve it to a name for filtering
- **Pattern**:
  ```sql
  LEFT JOIN `savvy-gtm-analytics.SavvyGTMData.User` sga_user
    ON v.Opp_SGA_Name__c = sga_user.Id
  WHERE (v.SGA_Owner_Name__c = @sgaName 
     OR v.Opp_SGA_Name__c = @sgaName 
     OR COALESCE(sga_user.Name, v.Opp_SGA_Name__c) = @sgaName)
  ```

### ‚ùå Filtering by FilterDate for Volume Metrics
- **WRONG**: `WHERE FilterDate IN date_range` for volume counts
- **RIGHT**: Use specific date fields (`mql_stage_entered_ts`, `converted_date_raw`, `Date_Became_SQO__c`, etc.)
- **WHY**: Each metric has its own date field. `FilterDate` is for general filtering, not metric-specific dates.

### ‚ùå Period Mode Without Resolution Check
- **WRONG**: Counting all records that entered stage in period
- **RIGHT**: Count only records that entered AND resolved (progressed or closed) in same period
- **WHY**: Period mode excludes in-flight records. Both entry and resolution must be in period.

### ‚ùå Cohort Mode Including Open Records
- **WRONG**: Including open records in cohort denominators
- **RIGHT**: Use `eligible_for_*_conversions` flags which only include resolved records
- **WHY**: Cohort mode measures efficiency of resolved records only. Open records skew results.

### ‚ùå Missing Opportunity-Level Resolution
- **WRONG**: Using `lead_closed_date` for SQL‚ÜíSQO resolution
- **RIGHT**: Use `StageName = 'Closed Lost'` and `Stage_Entered_Closed__c` for opportunity closure
- **WHY**: Once converted, resolution is tracked at Opportunity level, not Lead level.

### ‚ùå Validating with Immature Cohorts
- **WRONG**: Testing calculation changes with Q4 2025 and expecting stable rates
- **RIGHT**: Test with Q1/Q2 2025 (TIER 1) - these cohorts are fully baked
- **WHY**: SQO‚ÜíJoined takes 90-200 days to stabilize. Q4 2025 is only 13 days old.

### ‚ùå Not Using Pre-calculated Flags
- **WRONG**: `SUM(CASE WHEN is_mql = 1 AND is_sql = 1 THEN 1 END) / COUNT(*)` 
- **RIGHT**: `SUM(mql_to_sql_progression) / SUM(eligible_for_mql_conversions)`
- **WHY**: Flags handle edge cases (recycled leads, FilterDate checks, resolution status)

## Rules and Commands

### Git: Add, Commit, Push

Use these simple commands only. Do **not** chain with `&&` / `;` or use shell-specific syntax.

```
git add .
git commit -m "Your descriptive commit message"
git push
```

Run each command separately. The user runs them in their own terminal.

### Code Generation Rules

1. **Always use parameterized queries**: Never use string interpolation in SQL queries. Always use `@paramName` syntax with BigQuery parameters.

2. **Type safety first**: Always define TypeScript interfaces in `src/types/` before implementing query functions. Use `Raw*Result` types for BigQuery results.

3. **Error handling**: All API routes must have try/catch blocks and return appropriate HTTP status codes. Log errors but don't expose sensitive details.

4. **Date filtering**: When filtering by date, always use `TIMESTAMP(@paramName)` for BigQuery compatibility. Include time component for end dates: `endDate + ' 23:59:59'`.

5. **Deduplication**: For opportunity-level metrics (SQO, Joined, AUM), always use `is_sqo_unique`, `is_joined_unique`, or `is_primary_opp_record` flags.

6. **Record type filtering**: When querying SQOs, always include `recordtypeid = @recruitingRecordType` filter with `RECRUITING_RECORD_TYPE` constant.

7. **SGA Attribution for Opportunity Metrics**: 
   - **Lead-level metrics** (Prospects, Contacted, MQLs, SQLs): Filter by `SGA_Owner_Name__c = @sga` only
   - **Opportunity-level metrics** (SQOs, Joined, AUM): Must check BOTH `SGA_Owner_Name__c` AND `Opp_SGA_Name__c`
   - **Critical Issue**: `Opp_SGA_Name__c` may contain a Salesforce User ID (e.g., `005VS000000QHlBYAW`) instead of a name
   - **Required Fix**: Join with User table to resolve IDs to names: `LEFT JOIN \`savvy-gtm-analytics.SavvyGTMData.User\` sga_user ON v.Opp_SGA_Name__c = sga_user.Id`
   - **Filter Pattern**: `(v.SGA_Owner_Name__c = @sga OR v.Opp_SGA_Name__c = @sga OR COALESCE(sga_user.Name, v.Opp_SGA_Name__c) = @sga)`
   - **Why**: An SQO can be attributed via lead-level SGA (who worked the lead) OR opportunity-level SGA (who owns the opportunity). Missing the User table join causes SQOs to be excluded when `Opp_SGA_Name__c` contains an ID instead of a name.

### Testing Commands

Before committing changes that affect calculations:

1. Run `npm run build` to ensure TypeScript compiles
2. **Test with Q1 2025 filters** (TIER 1 - Primary validation):
   - SQLs: 123
   - SQOs: 96
   - Joined: 12
   - Contacted‚ÜíMQL: 4.94% (314/6,360)
   - SQL‚ÜíSQO: 70.83% (85/120)
   - SQO‚ÜíJoined: 12.20% (10/82)
3. If Q1 2025 matches, test with Q4 2025 for sanity check
4. **Never fail validation based on Q4 2025 rates** - they're still baking

### Code Review Checklist

When reviewing or modifying code:
- [ ] Read `docs/GROUND-TRUTH.md` for expected values
- [ ] Uses parameterized queries (no string interpolation)
- [ ] Has proper TypeScript types
- [ ] Handles errors gracefully
- [ ] Uses correct cohort date fields for each metric
- [ ] Uses pre-calculated flags (`*_progression`, `eligible_for_*`)
- [ ] Properly deduplicates opportunity-level metrics
- [ ] Filters by correct record type for SQO calculations
- [ ] **For opportunity-level metrics**: Checks both `SGA_Owner_Name__c` and `Opp_SGA_Name__c` with User table join
- [ ] **Verified against Q1/Q2 2025 ground truth**

### Debugging Workflow

1. **Identify the issue**: Check console logs, network requests, and component state
2. **Compare with scorecard**: If chart values differ, compare with `getConversionRates()` logic
3. **Test query directly**: Run BigQuery query in console to verify results
4. **Check date fields**: Ensure using correct date dimension for each metric
5. **Verify deduplication**: Check that `is_*_unique` flags are used correctly
6. **Test with known values**: Use Q1 2025 as primary test case (TIER 1)

### File Modification Rules

- **Query files**: Always maintain consistency between `getConversionRates()` and `getConversionTrends()`
- **Component files**: Keep data transformation minimal - do it in query functions
- **Type files**: Update types when data structures change
- **API routes**: Always apply permission filters via `getSessionPermissions(session)` (NOT `getUserPermissions()`)

### Common Patterns

**Query Pattern**:
```typescript
const { startDate, endDate } = buildDateRangeFromFilters(filters);
const params: Record<string, any> = { startDate, endDate: endDate + ' 23:59:59' };
// Add filters to params
const query = `SELECT ... WHERE ... AND TIMESTAMP(@startDate) ...`;
const results = await runQuery<RawType>(query, params);
```

**API Route Pattern**:
```typescript
import { getSessionPermissions } from '@/types/auth';

const session = await getServerSession(authOptions);
if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

const permissions = getSessionPermissions(session);  // NO DB query!
if (!permissions) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

// Use permissions.userId instead of querying User table
const userId = permissions.userId;

// Apply permission filters
const data = await getDataFunction(filters);
return NextResponse.json(data);
```

**Component Pattern**:
```typescript
'use client';
import { useState, useEffect } from 'react';
import { dashboardApi } from '@/lib/api-client';
// Fetch data, handle loading/error states, render UI
```

---

**Critical Reminders**:
1. **Ground Truth**: `docs/GROUND-TRUTH.md` is the source of truth - Q1/Q2 2025 values are IMMUTABLE
2. **Cohort Maturity**: Recent cohorts (Q4 2025) have artificially low SQO‚ÜíJoined rates - this is expected
3. **Pre-calculated Flags**: Always use `*_progression` and `eligible_for_*` flags from `vw_funnel_master`
4. **Validation Order**: Q1 2025 first ‚Üí Q2 2025 second ‚Üí Q4 2025 for sanity only
5. **Never fail on Q4**: If Q4 2025 SQO‚ÜíJoined is low, that's expected - cohort isn't mature

**Remember**: The scorecard calculations in `getConversionRates()` are correct. Use them as the reference implementation when fixing the trend chart.

---

## SGA Hub Feature Patterns

### Overview

The SGA Hub feature allows SGAs to track weekly goals, closed lost follow-ups, and quarterly progress. Admin/Manager roles can manage all SGAs via the SGA Management page.

**Key Files:**
- `src/app/dashboard/sga-hub/` - SGA Hub page and content
- `src/app/dashboard/sga-management/` - Admin SGA Management page
- `src/lib/queries/weekly-goals.ts` - Weekly goals Prisma queries
- `src/lib/queries/weekly-actuals.ts` - Weekly actuals BigQuery queries
- `src/lib/queries/quarterly-progress.ts` - Quarterly SQO progress queries
- `src/lib/queries/closed-lost.ts` - Closed lost records queries
- `src/types/sga-hub.ts` - SGA Hub type definitions
- `src/lib/utils/sga-hub-helpers.ts` - Date utilities and pacing calculations

### Critical Patterns

#### 1. Date Parsing - ALWAYS Use Local Dates

**‚ö†Ô∏è CRITICAL**: BigQuery `DATE` fields must be parsed as **local dates**, not UTC.

**WRONG:**
```typescript
const date = new Date(dateString); // Parses as UTC, causes timezone shifts
```

**RIGHT:**
```typescript
// In sga-hub-helpers.ts pattern:
const [year, month, day] = dateString.split('-').map(Number);
const date = new Date(year, month - 1, day); // Local date, no timezone shift
```

**Why**: Week validation (`isMonday`) and date formatting break if dates shift due to UTC parsing. Monday dates become Sunday in some timezones.

**Files using this pattern:**
- `src/lib/utils/sga-hub-helpers.ts` - All date functions
- `src/app/api/sga-hub/weekly-goals/route.ts` - Week validation
- `src/components/sga-hub/WeeklyGoalEditor.tsx` - Date display

#### 2. SGA Name Matching - Case-Sensitive

**‚ö†Ô∏è CRITICAL**: User `name` field MUST match BigQuery `SGA_Owner_Name__c` **exactly** (case-sensitive).

**Pattern:**
```typescript
// Get user name from Prisma
const user = await prisma.user.findUnique({ where: { email }, select: { name: true } });

// Use in BigQuery query
const query = `SELECT ... WHERE SGA_Owner_Name__c = @sgaName`;
const params = { sgaName: user.name }; // Exact match required
```

**Why**: BigQuery string matching is case-sensitive. "Eleni" ‚â† "Eleni Stefanopoulos" ‚â† "eleni stefanopoulos".

**Common Issue**: User created with name "Eleni" but BigQuery has "Eleni Stefanopoulos" ‚Üí no data returned.

**Solution**: Always verify name matches exactly. Update Prisma User.name to match BigQuery if needed.

#### 3. BigQuery View Column Names - Lowercase

**‚ö†Ô∏è IMPORTANT**: BigQuery views use **lowercase** column names, not Salesforce API names.

**WRONG:**
```sql
SELECT Opp_Name__c, Last_Contact_Date__c FROM vw_sga_closed_lost_sql_followup
```

**RIGHT:**
```sql
SELECT opp_name, last_contact_date FROM vw_sga_closed_lost_sql_followup
```

**Why**: BigQuery views transform Salesforce API names to lowercase. Always check view schema first using MCP.

**Pattern**: Use MCP to query `INFORMATION_SCHEMA.COLUMNS` before writing queries:
```sql
SELECT column_name, data_type 
FROM `savvy-gtm-analytics.savvy_analytics.INFORMATION_SCHEMA.COLUMNS` 
WHERE table_name = 'vw_sga_closed_lost_sql_followup'
```

#### 4. BigQuery DATE Field Handling

**‚ö†Ô∏è IMPORTANT**: BigQuery `DATE` fields can return as strings OR objects.

**Pattern:**
```typescript
function extractDate(value: any): string {
  if (typeof value === 'string') return value;
  if (value && typeof value === 'object' && 'value' in value) {
    return String(value.value);
  }
  return '';
}
```

**Why**: BigQuery DATE fields sometimes return as `{ value: "2026-01-15" }` instead of `"2026-01-15"`. Always handle both formats.

#### 5. Weekly Goals - Monday Validation

**Pattern:**
```typescript
// Always validate weekStartDate is a Monday
if (!isMonday(weekStartDate)) {
  return NextResponse.json(
    { error: 'weekStartDate must be a Monday' },
    { status: 400 }
  );
}
```

**Why**: Weekly goals are stored by Monday date. Non-Monday dates break week calculations.

**Helper**: `isMonday()` in `sga-hub-helpers.ts` uses local date parsing.

#### 6. Quarterly Pacing Calculation

**Pattern:**
```typescript
// Calculate expected SQOs based on days elapsed
const daysInQuarter = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
const daysElapsed = Math.max(0, Math.min(daysInQuarter, Math.ceil((today - startDate) / (1000 * 60 * 60 * 24)) + 1));
const expectedSqos = Math.round((goal / daysInQuarter) * daysElapsed * 10) / 10;
const pacingDiff = actual - expectedSqos;
```

**Formula**: `expectedSqos = (goal / daysInQuarter) √ó daysElapsed`

**Status Logic:**
- `pacingDiff >= 0.5` ‚Üí "ahead"
- `pacingDiff >= -0.5` ‚Üí "on-track"
- `pacingDiff < -0.5` ‚Üí "behind"

#### 7. Permission-Based Data Filtering

**Pattern:**
```typescript
// SGA users can only see their own data
if (permissions.role === 'sga') {
  // Use user.name as sgaName filter
  const user = await prisma.user.findUnique({ where: { email }, select: { name: true } });
  // Filter BigQuery by SGA_Owner_Name__c = user.name
} else if (['admin', 'manager'].includes(permissions.role)) {
  // Can view any SGA (optional userEmail param)
  const targetEmail = searchParams.get('userEmail') || session.user.email;
}
```

**Why**: SGAs should only see their own goals and data. Admin/Manager can view any SGA.

#### 8. Closed Lost Time Buckets

**Pattern:**
```typescript
// Normalize UI bucket format to BigQuery view format
function normalizeTimeBucket(bucket: string): string {
  const normalized = bucket.toLowerCase();
  if (normalized.includes('30-60') || normalized.includes('1 month')) return '1 month since last contact';
  if (normalized.includes('60-90') || normalized.includes('2 month')) return '2 months since last contact';
  // ... etc
}
```

**Why**: UI uses formats like "30-60 days" but BigQuery view uses "1 month since last contact". Must normalize.

#### 9. CSV Export Pattern

**Pattern:**
```typescript
// Generic CSV generation
function generateCSV<T>(data: T[], columns: { key: string; header: string }[], filename: string) {
  const headers = columns.map(col => col.header);
  const csvContent = [
    headers.join(','),
    ...data.map(row => 
      columns.map(col => {
        const value = String(row[col.key] ?? '');
        // Escape quotes and wrap if contains comma/quote/newline
        if (value.includes(',') || value.includes('"') || value.includes('\n')) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value;
      }).join(',')
    )
  ].join('\n');
  
  // Download via Blob API
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `${filename}_${new Date().toISOString().split('T')[0]}.csv`;
  link.click();
}
```

**Location**: `src/lib/utils/sga-hub-csv-export.ts`

### Common Pitfalls - SGA Hub

#### ‚ùå Parsing Dates as UTC
- **WRONG**: `new Date(dateString)` for BigQuery DATE fields
- **RIGHT**: Parse as local date: `new Date(year, month - 1, day)`
- **WHY**: Causes week validation failures and incorrect date displays

#### ‚ùå Using Salesforce API Names in BigQuery Views
- **WRONG**: `SELECT Opp_Name__c FROM vw_sga_closed_lost_sql_followup`
- **RIGHT**: `SELECT opp_name FROM vw_sga_closed_lost_sql_followup`
- **WHY**: Views use lowercase column names, not Salesforce API names

#### ‚ùå Case-Insensitive Name Matching
- **WRONG**: Assuming "Eleni" matches "Eleni Stefanopoulos"
- **RIGHT**: Exact case-sensitive match required
- **WHY**: BigQuery string matching is case-sensitive. Always verify User.name matches SGA_Owner_Name__c exactly

#### ‚ùå Not Handling DATE Object Format
- **WRONG**: `value.split('-')` when value might be `{ value: "2026-01-15" }`
- **RIGHT**: Use `extractDate()` helper to handle both string and object formats
- **WHY**: BigQuery DATE fields can return as objects

#### ‚ùå Auto-Selecting First SGA in Dropdowns
- **WRONG**: Auto-selecting first SGA when data loads
- **RIGHT**: Default to "Select an SGA..." empty value
- **WHY**: Better UX - user explicitly chooses which SGA to view

#### ‚ùå Using Tremor Select for Native Styling
- **WRONG**: Using Tremor `Select` component when native `<select>` styling is needed
- **RIGHT**: Use native HTML `<select>` with Tailwind classes for consistent styling
- **WHY**: Tremor Select has transparent background issues. Native select matches other inputs.

### SGA Hub File Structure

```
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sga-hub/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ weekly-goals/route.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ weekly-actuals/route.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quarterly-goals/route.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quarterly-progress/route.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sqo-details/route.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ closed-lost/route.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ admin/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ sga-overview/route.ts
‚îÇ   ‚îî‚îÄ‚îÄ dashboard/
‚îÇ       ‚îú‚îÄ‚îÄ sga-hub/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ SGAHubContent.tsx
‚îÇ       ‚îî‚îÄ‚îÄ sga-management/
‚îÇ           ‚îú‚îÄ‚îÄ page.tsx
‚îÇ           ‚îî‚îÄ‚îÄ SGAManagementContent.tsx
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ sga-hub/
‚îÇ       ‚îú‚îÄ‚îÄ WeeklyGoalsTable.tsx
‚îÇ       ‚îú‚îÄ‚îÄ WeeklyGoalEditor.tsx
‚îÇ       ‚îú‚îÄ‚îÄ ClosedLostTable.tsx
‚îÇ       ‚îú‚îÄ‚îÄ QuarterlyProgressCard.tsx
‚îÇ       ‚îú‚îÄ‚îÄ SQODetailTable.tsx
‚îÇ       ‚îú‚îÄ‚îÄ QuarterlyProgressChart.tsx
‚îÇ       ‚îú‚îÄ‚îÄ AdminSGATable.tsx
‚îÇ       ‚îú‚îÄ‚îÄ BulkGoalEditor.tsx
‚îÇ       ‚îú‚îÄ‚îÄ IndividualGoalEditor.tsx
‚îÇ       ‚îî‚îÄ‚îÄ SGAHubTabs.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ queries/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ weekly-goals.ts (Prisma)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ weekly-actuals.ts (BigQuery)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quarterly-goals.ts (Prisma)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quarterly-progress.ts (BigQuery)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ closed-lost.ts (BigQuery)
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ sga-hub-helpers.ts (date utils, pacing calc)
‚îÇ       ‚îî‚îÄ‚îÄ sga-hub-csv-export.ts (CSV export functions)
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ sga-hub.ts (all SGA Hub types)
```

### Testing SGA Hub Features

**Before making changes:**
1. Verify User.name matches BigQuery SGA_Owner_Name__c exactly
2. Test with known SGA (e.g., Eleni Stefanopoulos)
3. Verify date parsing doesn't cause timezone shifts
4. Check BigQuery view column names using MCP
5. Test permission filtering (SGA sees only own data, Admin sees all)

**Common Test Cases:**
- Week validation: Monday dates only
- Date display: Correct week ranges (no "Jan 11 - 11, 2026" issues)
- Name matching: Exact case-sensitive match
- Pacing calculation: Formula matches expected SQOs per day
- CSV export: All columns included, proper escaping

---

## SGA Drill-Down Feature Patterns

### Overview

The drill-down feature allows users to click on metric values (Initial Calls, Qualification Calls, SQOs) to see underlying records, and then click on any record to view full details. This pattern is used in both SGA Management and SGA Hub pages.

**Key Files:**
- `src/types/drill-down.ts` - Drill-down type definitions
- `src/lib/queries/drill-down.ts` - BigQuery queries for drill-down records
- `src/app/api/sga-hub/drill-down/` - API routes for drill-down data
- `src/components/sga-hub/MetricDrillDownModal.tsx` - Drill-down modal component
- `src/components/sga-hub/ClickableMetricValue.tsx` - Reusable clickable number component
- `src/components/dashboard/RecordDetailModal.tsx` - Record detail modal (with back button support)

### Critical Patterns

#### 1. BigQuery DATE vs TIMESTAMP Type Casting

**‚ö†Ô∏è CRITICAL**: When comparing BigQuery `DATE` fields with `TIMESTAMP` parameters, you MUST cast the DATE field to TIMESTAMP.

**WRONG:**
```sql
WHERE v.Initial_Call_Scheduled_Date__c >= TIMESTAMP(@weekStartDate)
-- Error: No matching signature for operator >= for argument types: DATE, TIMESTAMP
```

**RIGHT:**
```sql
WHERE TIMESTAMP(v.Initial_Call_Scheduled_Date__c) >= TIMESTAMP(@weekStartDate)
```

**Why**: BigQuery DATE and TIMESTAMP are different types. DATE fields must be cast to TIMESTAMP for comparison with TIMESTAMP parameters.

**Files using this pattern:**
- `src/lib/queries/drill-down.ts` - All date comparisons in drill-down queries
- `src/lib/queries/quarterly-progress.ts` - SQO date comparisons

#### 2. Two-Part Query Structure - CRITICAL REMINDER

**‚ö†Ô∏è CRITICAL**: The `getClosedLostRecords` function has **TWO separate query parts** that **BOTH must be updated** when modifying:

1. **Query Part 1**: 30-179 days bucket (queries from `vw_sga_closed_lost_sql_followup` view)
2. **Query Part 2**: 180+ days bucket (queries from base tables with CTEs)

**When adding JOINs or new fields:**
- ‚úÖ Update BOTH query parts
- ‚úÖ Add `v.primary_key` to SELECT in BOTH queries
- ‚úÖ Add LEFT JOIN with `vw_funnel_master` in BOTH queries
- ‚úÖ Prefix all column references with table aliases (`cl.` for Part 1, `w.` for Part 2)

**Why**: If only one part is updated, records from the other time bucket will be missing fields, causing RecordDetailModal to fail.

**Verification Checklist:**
- [ ] Query Part 1 (30-179 days) updated
- [ ] Query Part 2 (180+ days) updated
- [ ] All column references prefixed with table aliases
- [ ] Both queries use LEFT JOIN with `vw_funnel_master`

#### 3. Nested Modal State Management

**Pattern:**
```typescript
// Drill-down modal state
const [drillDownOpen, setDrillDownOpen] = useState(false);
const [drillDownMetricType, setDrillDownMetricType] = useState<MetricType | null>(null);
const [drillDownRecords, setDrillDownRecords] = useState<DrillDownRecord[]>([]);
const [drillDownLoading, setDrillDownLoading] = useState(false);
const [drillDownError, setDrillDownError] = useState<string | null>(null);
const [drillDownTitle, setDrillDownTitle] = useState('');
const [drillDownContext, setDrillDownContext] = useState<DrillDownContext | null>(null);

// Record detail modal state
const [recordDetailOpen, setRecordDetailOpen] = useState(false);
const [recordDetailId, setRecordDetailId] = useState<string | null>(null);

// Handler: Open drill-down from metric click
const handleMetricClick = async (sgaName, metricType, weekStartDate, weekEndDate) => {
  setDrillDownLoading(true);
  setDrillDownOpen(true);
  // Store context for back button
  setDrillDownContext({ metricType, title, sgaName, weekStartDate, weekEndDate });
  // Fetch records...
};

// Handler: Open record detail from drill-down row click
const handleRecordClick = (primaryKey: string) => {
  setDrillDownOpen(false); // Close drill-down
  setRecordDetailId(primaryKey);
  setRecordDetailOpen(true); // Open record detail
};

// Handler: Back button returns to drill-down
const handleBackToDrillDown = () => {
  setRecordDetailOpen(false);
  setRecordDetailId(null);
  setDrillDownOpen(true); // Reopen drill-down with stored context
};
```

**Why**: Nested modals require careful state management. The drill-down context must be preserved when opening record detail, so the back button can restore it.

#### 4. API Route Pattern for Drill-Down

**Pattern:**
```typescript
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const permissions = await getUserPermissions(session.user.email);
    if (!['admin', 'manager', 'sga'].includes(permissions.role)) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const targetUserEmail = searchParams.get('userEmail'); // For admin viewing other SGAs
    const weekStartDate = searchParams.get('weekStartDate');
    const weekEndDate = searchParams.get('weekEndDate');

    // Validate required parameters
    if (!weekStartDate || !weekEndDate) {
      return NextResponse.json(
        { error: 'Missing required parameters' },
        { status: 400 }
      );
    }

    // Determine which user's records to fetch
    let userEmail = session.user.email;
    if (targetUserEmail) {
      // Only admin/manager can view other users' records
      if (!['admin', 'manager'].includes(permissions.role)) {
        return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
      }
      userEmail = targetUserEmail;
    }

    // Get user to retrieve name for BigQuery filter
    const user = await prisma.user.findUnique({
      where: { email: userEmail },
      select: { name: true },
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Fetch drill-down records
    const records = await getDrillDownFunction(user.name, weekStartDate, weekEndDate);

    return NextResponse.json({ records });
  } catch (error) {
    console.error('Error fetching drill-down:', error);
    return NextResponse.json(
      { error: 'Failed to fetch records' },
      { status: 500 }
    );
  }
}
```

**Key Points:**
- SGA users viewing their own data should NOT pass `userEmail` parameter
- Admin/Manager can pass `userEmail` to view other SGAs' data
- Always fetch user.name from Prisma to match BigQuery `SGA_Owner_Name__c`

#### 5. Clickable Metric Value Pattern

**Pattern:**
```typescript
// For entire label+number clickable (AdminSGATable)
<button
  onClick={(e) => {
    e.stopPropagation();
    onMetricClick(sgaEmail, sgaName, 'initial-calls', false);
  }}
  className="text-sm text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-gray-900 dark:hover:text-gray-100 px-2 py-1 rounded transition-colors duration-150 cursor-pointer"
>
  Initial Calls: <span className="text-xl font-bold">{value}</span>
</button>

// For cell content clickable (WeeklyGoalsTable)
<button
  onClick={(e) => {
    e.stopPropagation();
    onMetricClick(weekStartDate, 'initial-calls');
  }}
  className="flex flex-col items-end hover:bg-gray-100 dark:hover:bg-gray-700 px-2 py-1 rounded transition-colors duration-150 cursor-pointer w-full"
>
  <div className="flex items-center gap-2">
    <span className="text-lg font-semibold">{actual}</span>
    <span className="text-sm text-gray-500">/ {goal}</span>
  </div>
  <span className="text-xs font-medium">{diff}</span>
</button>
```

**Why**: Hover bounding box provides clear visual feedback. Entire blocks are clickable for better UX.

#### 6. RecordDetailModal Back Button Support

**Pattern:**
```typescript
// Add to RecordDetailModal props
interface RecordDetailModalProps {
  // ... existing props ...
  showBackButton?: boolean;
  onBack?: () => void;
  backButtonLabel?: string;
}

// In component header
{showBackButton && onBack && (
  <button
    onClick={onBack}
    className="flex items-center gap-1 text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 transition-colors"
  >
    {backButtonLabel || '‚Üê Back to list'}
  </button>
)}
```

**Why**: Allows nested modal flow - drill-down ‚Üí record detail ‚Üí back to drill-down.

#### 7. SGA User API Parameter Handling

**‚ö†Ô∏è IMPORTANT**: SGA users viewing their own data in SGA Hub should NOT pass `userEmail` parameter to API calls.

**WRONG:**
```typescript
// In SGAHubContent.tsx for SGA users
await dashboardApi.getSQODrillDown(sgaName, { weekStartDate, weekEndDate }, session?.user?.email);
// This causes 403 Forbidden - API rejects userEmail for non-admin/manager
```

**RIGHT:**
```typescript
// In SGAHubContent.tsx for SGA users
await dashboardApi.getSQODrillDown(sgaName, { weekStartDate, weekEndDate });
// API route defaults to session user's email
```

**Why**: API routes check permissions. If `userEmail` is passed for a non-admin/manager, it's rejected. For SGA users, omit the parameter and let the API use the session user.

#### 8. Drill-Down Type Definitions

**Pattern:**
```typescript
// Base interface with common fields
export interface DrillDownRecordBase {
  primaryKey: string;
  advisorName: string;
  source: string;
  channel: string;
  tofStage: string;
  leadUrl: string | null;
  opportunityUrl: string | null;
}

// Specific record types extend base
export interface InitialCallRecord extends DrillDownRecordBase {
  initialCallDate: string;
  leadScoreTier: string | null;
}

// Union type for all drill-down records
export type DrillDownRecord = InitialCallRecord | QualificationCallRecord | SQODrillDownRecord;
```

**Why**: Type safety ensures correct field access. Union type allows type guards for conditional rendering.

#### 9. Date Extraction Helper Pattern

**Pattern:**
```typescript
function extractDateValue(
  field: { value: string } | string | null | undefined
): string | null {
  if (!field) return null;
  
  // Handle object format: { value: "2025-01-15T10:30:00Z" }
  if (typeof field === 'object' && field !== null && 'value' in field) {
    return typeof field.value === 'string' ? field.value : null;
  }
  
  // Handle string format: "2025-01-15" or "2025-01-15T10:30:00Z"
  if (typeof field === 'string') {
    return field;
  }
  
  return null;
}
```

**Why**: BigQuery DATE/TIMESTAMP fields can return as strings OR objects. Always handle both formats.

### Common Pitfalls - Drill-Down Feature

#### ‚ùå Not Casting DATE to TIMESTAMP
- **WRONG**: `v.Initial_Call_Scheduled_Date__c >= TIMESTAMP(@date)`
- **RIGHT**: `TIMESTAMP(v.Initial_Call_Scheduled_Date__c) >= TIMESTAMP(@date)`
- **WHY**: BigQuery type mismatch error - DATE and TIMESTAMP are incompatible without casting

#### ‚ùå Updating Only One Query Part in Closed Lost
- **WRONG**: Updating only the 30-179 days query, forgetting the 180+ days query
- **RIGHT**: Update BOTH query parts when adding JOINs or fields
- **WHY**: Missing fields in one bucket causes RecordDetailModal to fail for those records

#### ‚ùå Passing userEmail for SGA Users
- **WRONG**: SGA user passes their own email to API route
- **RIGHT**: Omit userEmail parameter - API defaults to session user
- **WHY**: API rejects userEmail parameter for non-admin/manager roles

#### ‚ùå Not Storing Drill-Down Context
- **WRONG**: Opening record detail without storing drill-down state
- **RIGHT**: Store `drillDownContext` before closing drill-down modal
- **WHY**: Back button needs context to restore drill-down state

#### ‚ùå Not Rendering Modals in JSX
- **WRONG**: Importing modals but not rendering them in component return
- **RIGHT**: Always render modals at the bottom of component JSX
- **WHY**: Modals won't appear if not in the render tree

#### ‚ùå Using Number Inputs for Goal Editing
- **WRONG**: `type="number"` input with spinner arrows
- **RIGHT**: `type="text"` with `inputMode="numeric"` for free text entry
- **WHY**: Better UX - users can clear field and type freely without spinner interference

### Drill-Down File Structure

```
src/
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ drill-down.ts (MetricType, DrillDownRecord types, DrillDownContext)
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îî‚îÄ‚îÄ queries/
‚îÇ       ‚îî‚îÄ‚îÄ drill-down.ts (getInitialCallsDrillDown, getQualificationCallsDrillDown, getSQODrillDown)
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îî‚îÄ‚îÄ sga-hub/
‚îÇ           ‚îî‚îÄ‚îÄ drill-down/
‚îÇ               ‚îú‚îÄ‚îÄ initial-calls/route.ts
‚îÇ               ‚îú‚îÄ‚îÄ qualification-calls/route.ts
‚îÇ               ‚îî‚îÄ‚îÄ sqos/route.ts
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ sga-hub/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MetricDrillDownModal.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ClickableMetricValue.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AdminSGATable.tsx (with clickable metrics)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WeeklyGoalsTable.tsx (with clickable metrics)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ QuarterlyProgressCard.tsx (with clickable SQO count)
‚îÇ   ‚îî‚îÄ‚îÄ dashboard/
‚îÇ       ‚îî‚îÄ‚îÄ RecordDetailModal.tsx (with back button support)
‚îî‚îÄ‚îÄ app/
    ‚îî‚îÄ‚îÄ dashboard/
        ‚îú‚îÄ‚îÄ sga-management/
        ‚îÇ   ‚îî‚îÄ‚îÄ SGAManagementContent.tsx (modal state management)
        ‚îî‚îÄ‚îÄ sga-hub/
            ‚îî‚îÄ‚îÄ SGAHubContent.tsx (modal state management)
```

### Testing Drill-Down Features

**Before making changes:**
1. Verify BigQuery DATE fields are cast to TIMESTAMP for comparisons
2. Test nested modal flow: metric click ‚Üí drill-down ‚Üí record click ‚Üí back button
3. Verify SGA users can view their own data without userEmail parameter
4. Test admin/manager viewing other SGAs' data with userEmail parameter
5. Verify closed lost queries include primary_key in BOTH query parts

**Common Test Cases:**
- BigQuery type casting: DATE fields cast to TIMESTAMP
- Nested modals: Back button restores drill-down state
- Permission handling: SGA users don't pass userEmail
- Two-part queries: Both closed lost query parts updated
- Clickable areas: Entire label+number blocks are clickable
- Hover effects: Light gray bounding box appears on hover

---

## Saved Reports Feature Patterns

### Overview

The Saved Reports feature allows users to save filter presets with custom feature selection (which dashboard components to show). Users can create personal reports, and admins can create template reports visible to all users.

**Key Files:**
- `src/types/saved-reports.ts` - Saved report type definitions and FeatureSelection interface
- `src/app/api/saved-reports/` - API routes for CRUD operations
- `src/components/dashboard/SaveReportModal.tsx` - Modal for creating/editing reports
- `src/components/dashboard/SavedReportsDropdown.tsx` - Dropdown for selecting reports
- `src/components/dashboard/DeleteConfirmModal.tsx` - Confirmation modal for deletion
- `src/app/dashboard/page.tsx` - Main dashboard integration with feature selection state

### Critical Patterns

#### 1. Feature Selection State Management

**‚ö†Ô∏è CRITICAL**: Feature selection controls which dashboard components are visible. State is managed in `src/app/dashboard/page.tsx`:

```typescript
const [featureSelection, setFeatureSelection] = useState<FeatureSelection>(
  DEFAULT_FEATURE_SELECTION
);
```

**Pattern**: When loading a saved report:
```typescript
const applyReport = useCallback((report: SavedReport) => {
  setActiveReportId(report.id);
  setFilters(report.filters as DashboardFilters);
  setFeatureSelection(getEffectiveFeatureSelection(report.featureSelection));
  if (report.viewMode) {
    setViewMode(report.viewMode as ViewMode);
  }
}, []);
```

**Why**: `getEffectiveFeatureSelection()` handles backward compatibility - reports without featureSelection show all features, and converts old grouped format to new granular format.

#### 2. Granular Feature Selection Structure

**‚ö†Ô∏è CRITICAL**: Feature selection uses granular control over individual scorecards and conversion rate cards, not grouped components.

**Pattern**: Features are individually selectable:

```typescript
interface FeatureSelection {
  scorecards: {
    prospects: boolean;      // Individual
    contacted: boolean;      // Individual
    mqls: boolean;          // Individual
    sqls: boolean;         // Individual
    sqos: boolean;         // Individual
    signed: boolean;       // Individual
    joined: boolean;       // Individual
    openPipeline: boolean; // Individual (standalone section)
  };
  conversionRates: {
    contactedToMql: boolean;  // Individual
    mqlToSql: boolean;       // Individual
    sqlToSqo: boolean;       // Individual
    sqoToJoined: boolean;     // Individual
  };
  charts: {
    conversionTrends: boolean;  // Individual
    volumeTrends: boolean;       // Individual
  };
  tables: {
    channelPerformance: boolean;  // Individual
    sourcePerformance: boolean;   // Individual
    detailRecords: boolean;       // Individual
  };
}
```

**Why**: Users can selectively show/hide individual metrics. "Open Pipeline" is its own standalone scorecard section, not grouped with volume scorecards.

#### 3. Conditional Data Fetching Based on Feature Selection

**‚ö†Ô∏è CRITICAL**: Only fetch data for visible features to improve performance.

**Pattern**:
```typescript
// Check if any scorecard metrics are visible
const needsMetrics = 
  featureSelection.scorecards.prospects ||
  featureSelection.scorecards.contacted ||
  featureSelection.scorecards.mqls ||
  featureSelection.scorecards.sqls ||
  featureSelection.scorecards.sqos ||
  featureSelection.scorecards.signed ||
  featureSelection.scorecards.joined ||
  featureSelection.scorecards.openPipeline ||
  featureSelection.tables.channelPerformance ||
  featureSelection.tables.sourcePerformance;

if (needsMetrics) {
  promises.push(dashboardApi.getFunnelMetrics(currentFilters, viewMode).then(setMetrics));
}

// Check if conversion rates are visible
if (featureSelection.conversionRates.contactedToMql || 
    featureSelection.conversionRates.mqlToSql ||
    featureSelection.conversionRates.sqlToSqo ||
    featureSelection.conversionRates.sqoToJoined) {
  promises.push(dashboardApi.getConversionRates(currentFilters, viewMode).then(setConversionRates));
}
```

**Why**: Reduces unnecessary API calls and improves dashboard load time.

#### 4. Conditional Component Rendering

**Pattern**: Wrap each dashboard component with feature selection check:

```typescript
{featureSelection.scorecards.prospects && viewMode === 'fullFunnel' && metrics && (
  <CardErrorBoundary>
    <FullFunnelScorecards visibleMetrics={{ prospects: true }} ... />
  </CardErrorBoundary>
)}

{featureSelection.scorecards.sqls && metrics && (
  <CardErrorBoundary>
    <Scorecards visibleMetrics={{ sqls: true }} ... />
  </CardErrorBoundary>
)}

{featureSelection.conversionRates.contactedToMql && conversionRates && (
  <CardErrorBoundary>
    <ConversionRateCards visibleRates={{ contactedToMql: true }} ... />
  </CardErrorBoundary>
)}
```

**Why**: Maintains ErrorBoundary pattern while respecting granular feature selection. Components receive `visibleMetrics`/`visibleRates` props for internal conditional rendering.

#### 5. View Mode Override for Custom Reports

**‚ö†Ô∏è CRITICAL**: When loading a custom report, the report's `viewMode` should override the current view mode.

**Pattern**:
```typescript
const applyReport = useCallback((report: SavedReport) => {
  setActiveReportId(report.id);
  setFilters(report.filters as DashboardFilters);
  setFeatureSelection(getEffectiveFeatureSelection(report.featureSelection));
  // Override view mode if report has one
  if (report.viewMode) {
    setViewMode(report.viewMode as ViewMode);
  }
}, []);
```

**Why**: Custom reports should display exactly as saved, regardless of current view mode setting.

#### 6. Default Report Loading on Dashboard Mount

**Pattern**:
```typescript
useEffect(() => {
  const initializeReports = async () => {
    await fetchSavedReports();
    await loadDefaultReport();
  };
  initializeReports();
}, [fetchSavedReports, loadDefaultReport]);

const loadDefaultReport = useCallback(async () => {
  try {
    const defaultReport = await dashboardApi.getDefaultReport();
    if (defaultReport) {
      applyReport(defaultReport);
    }
  } catch (error) {
    console.error('Failed to load default report:', error);
  }
}, [applyReport]);
```

**Why**: Users expect their default report to load automatically when visiting the dashboard. Ensure `fetchSavedReports()` completes before `loadDefaultReport()`.

#### 7. Active Report Clearing on Manual Filter Changes

**Pattern**:
```typescript
onFiltersChange={(newFilters) => {
  setFilters(newFilters);
  setActiveReportId(null); // Clear active report when manually changing filters
}}
```

**Why**: If user manually changes filters, they're no longer viewing a saved report. Clear the active report ID to reflect this.

#### 8. Admin Template Access Control

**Pattern**:
```typescript
// In API routes
const permissions = await getUserPermissions(session.user.email);
const isAdminTemplate = reportType === 'admin_template';
if (isAdminTemplate && !['admin', 'manager'].includes(permissions.role)) {
  return NextResponse.json({ error: 'Only admins can create templates' }, { status: 403 });
}

// In SavedReportsDropdown - pass isAdmin prop
<SavedReportsDropdown
  isAdmin={isAdmin}
  // ... other props
/>

// In dropdown - conditionally enable edit/delete for admin templates
{report.reportType === 'admin_template' && (
  <ReportItem
    canEdit={isAdmin}
    canDelete={isAdmin}
    // ... other props
  />
)}
```

**Why**: Only admins/managers can create, edit, and delete templates. Regular users can view and duplicate templates but cannot modify them. Admin templates have `userId` set to creator's ID (not null) for tracking, but `reportType` field distinguishes them.

#### 9. One Default Per User Enforcement

**‚ö†Ô∏è CRITICAL**: Prisma doesn't support WHERE clauses in `@@unique` constraints. Must enforce in application logic.

**Pattern**:
```typescript
// When setting as default, unset any existing default FIRST
if (isDefault && !isAdminTemplate) {
  await prisma.savedReport.updateMany({
    where: {
      userId: user.id,
      isDefault: true,
      isActive: true,
      id: { not: params.id }, // Exclude current report if updating
    },
    data: { isDefault: false },
  });
}

// Then set this report as default
await prisma.savedReport.update({
  where: { id: params.id },
  data: { isDefault: true },
});
```

**Why**: Ensures only one default report per user. Must be done in application logic, not database constraint.

#### 10. Backward Compatibility for Feature Selection

**Pattern**: Use `getEffectiveFeatureSelection()` helper:

```typescript
export function getEffectiveFeatureSelection(
  featureSelection: FeatureSelection | null | undefined
): FeatureSelection {
  if (!featureSelection) {
    return DEFAULT_FEATURE_SELECTION; // Show all features
  }
  
  // Handle backward compatibility: convert old grouped format to new granular format
  const oldFormat = featureSelection as any;
  if (oldFormat.scorecards?.fullFunnel !== undefined || oldFormat.scorecards?.volume !== undefined) {
    // Old format detected - convert to new format
    const fullFunnel = oldFormat.scorecards?.fullFunnel ?? true;
    const volume = oldFormat.scorecards?.volume ?? true;
    return {
      scorecards: {
        prospects: fullFunnel,
        contacted: fullFunnel,
        mqls: fullFunnel,
        sqls: volume,
        sqos: volume,
        signed: volume,
        joined: volume,
        openPipeline: volume,
      },
      // ... convert conversionRates from boolean to object if needed
    };
  }
  
  // New format - merge with defaults for backward compatibility
  return {
    scorecards: {
      prospects: featureSelection.scorecards?.prospects ?? true,
      contacted: featureSelection.scorecards?.contacted ?? true,
      // ... etc
    },
    // ... etc
  };
}
```

**Why**: Old reports without featureSelection should show all features. Old reports with grouped format (fullFunnel/volume) are converted to granular format. New reports use granular format directly.

#### 11. Admin Template userId Tracking

**‚ö†Ô∏è CRITICAL**: Admin templates should have `userId` set to the creator's ID (not null) for tracking purposes.

**Pattern**:
```typescript
// In POST /api/saved-reports/route.ts
const report = await prisma.savedReport.create({
  data: {
    userId: user.id, // Always set userId, even for admin templates
    name,
    description,
    filters,
    featureSelection,
    viewMode,
    dashboard: 'funnel_performance',
    reportType: isAdminTemplate ? 'admin_template' : 'user',
    isDefault,
    isActive: true,
    createdBy: user.email,
  },
});
```

**Why**: `userId` tracks who created the template (for edit/delete permissions). `reportType` field distinguishes admin templates from user reports. This allows admins to edit/delete templates they created.

### Common Pitfalls - Saved Reports

#### ‚ùå Not Clearing Active Report on Manual Filter Changes
- **WRONG**: User changes filters manually but `activeReportId` still set
- **RIGHT**: Clear `activeReportId` when filters change manually
- **WHY**: UI should reflect that user is no longer viewing a saved report

#### ‚ùå Fetching Data for Hidden Features
- **WRONG**: Always fetching all data regardless of feature selection
- **RIGHT**: Conditionally fetch based on `featureSelection` state
- **WHY**: Improves performance and reduces unnecessary API calls

#### ‚ùå Not Overriding View Mode When Loading Custom Report
- **WRONG**: Loading report but keeping current view mode
- **RIGHT**: Set `viewMode` from report if present
- **WHY**: Custom reports should display exactly as saved

#### ‚ùå Using Database Constraint for One Default Per User
- **WRONG**: `@@unique([userId, isDefault], where: { isDefault: true })`
- **RIGHT**: Enforce in application logic with `updateMany` before setting default
- **WHY**: Prisma doesn't support WHERE clauses in `@@unique` constraints

#### ‚ùå Using getUserPermissions Instead of getSessionPermissions
- **WRONG**: `const permissions = await getUserPermissions(email);` // Queries DB!
- **RIGHT**: `const permissions = getSessionPermissions(session);` // No DB query
- **WHY**: Session already contains permissions from JWT. getUserPermissions always queries DB unnecessarily.

#### ‚ùå Not Handling Null featureSelection in Saved Reports
- **WRONG**: `report.featureSelection` used directly
- **RIGHT**: `getEffectiveFeatureSelection(report.featureSelection)`
- **WHY**: Backward compatibility - old reports may have null featureSelection

#### ‚ùå Setting userId to null for Admin Templates
- **WRONG**: `userId: isAdminTemplate ? null : user.id`
- **RIGHT**: `userId: user.id` (always set to creator's ID)
- **WHY**: Tracks creator for edit/delete permissions. `reportType` field distinguishes admin templates.

#### ‚ùå Not Passing isAdmin Prop to SavedReportsDropdown
- **WRONG**: `<SavedReportsDropdown ... />` without `isAdmin` prop
- **RIGHT**: `<SavedReportsDropdown isAdmin={isAdmin} ... />`
- **WHY**: Dropdown needs to know if user is admin to enable edit/delete for admin templates

### Saved Reports File Structure

```
src/
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ saved-reports.ts (FeatureSelection, SavedReport, SavedReportInput, helper functions)
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îî‚îÄ‚îÄ saved-reports/
‚îÇ           ‚îú‚îÄ‚îÄ route.ts (GET list, POST create)
‚îÇ           ‚îú‚îÄ‚îÄ [id]/route.ts (GET, PUT, DELETE)
‚îÇ           ‚îú‚îÄ‚îÄ [id]/set-default/route.ts (POST)
‚îÇ           ‚îú‚îÄ‚îÄ [id]/duplicate/route.ts (POST)
‚îÇ           ‚îî‚îÄ‚îÄ default/route.ts (GET)
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ dashboard/
‚îÇ       ‚îú‚îÄ‚îÄ SaveReportModal.tsx (granular feature selection UI)
‚îÇ       ‚îú‚îÄ‚îÄ SavedReportsDropdown.tsx (with isAdmin prop)
‚îÇ       ‚îî‚îÄ‚îÄ DeleteConfirmModal.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îî‚îÄ‚îÄ api-client.ts (dashboardApi.getSavedReports, etc.)
‚îî‚îÄ‚îÄ app/
    ‚îî‚îÄ‚îÄ dashboard/
        ‚îî‚îÄ‚îÄ page.tsx (feature selection state, conditional rendering, conditional fetching)
```

### Testing Saved Reports Features

**Before making changes:**
1. Verify feature selection state is properly initialized
2. Test default report loading on page refresh
3. Verify conditional data fetching (check Network tab)
4. Test admin template creation/editing permissions
5. Verify one default per user enforcement
6. Test backward compatibility with reports without featureSelection
7. Verify granular feature selection (individual scorecards/conversion rates)
8. Test view mode override when loading custom reports
9. Verify admin templates have userId set to creator's ID

**Common Test Cases:**
- Default report loads on dashboard visit
- Manual filter changes clear active report
- Hidden features don't fetch data
- Individual scorecards can be hidden/shown independently
- Individual conversion rate cards can be hidden/shown independently
- Custom report view mode overrides current view mode
- Admin templates visible to all users
- Non-admins cannot edit/delete admin templates (only duplicate)
- Admins can edit/delete templates they created
- One default per user enforced
- Reports without featureSelection show all features
- Old grouped format reports converted to granular format

---

## Explore Feature - Drilldown and Detail Lists

### Generic Detail List Template for Lead-Level Metrics (CRITICAL)

**‚ö†Ô∏è CRITICAL**: When implementing drilldown for lead-level metrics (MQLs, SQLs, Contacted, Prospects), you MUST use the `generic_detail_list` template, NOT `sqo_detail_list`.

**Problem**: `sqo_detail_list` is hardcoded to filter by `Date_Became_SQO__c` and `is_sqo_unique = 1`, which won't work for MQLs, SQLs, or other lead-level metrics.

**Solution**: Use `generic_detail_list` template which adapts based on the `metric` parameter.

**Implementation Pattern:**

1. **Add Template to QUERY_TEMPLATES** (`src/lib/semantic-layer/query-templates.ts`):
   ```typescript
   generic_detail_list: {
     id: 'generic_detail_list',
     description: 'List detail records for any volume metric',
     parameters: {
       metric: { type: 'metric', required: true },
       dateRange: { type: 'dateRange', required: false }, // Optional for "all time"
       filters: { type: 'filter[]', required: false },
     },
     visualization: 'table',
   }
   ```

2. **Add Compiler Function** (`src/lib/semantic-layer/query-compiler.ts`):
   - Create `compileGenericDetailList()` function
   - Map metric to appropriate date field, filter, and column alias:
     - MQLs: `mql_stage_entered_ts`, `is_mql = 1`, `mql_date`
     - SQLs: `converted_date_raw`, `is_sql = 1`, `sql_date`
     - Contacted: `stage_entered_contacting__c`, `is_contacted = 1`, `contacted_date`
     - Prospects: `FilterDate`, no filter, `prospect_date`
   - Use `DATE()` conversion for consistency (matches period comparison pattern)
   - Include AUM columns only for opportunity-level metrics (SQOs, Joined)

3. **Register in Compiler Switch**:
   ```typescript
   case 'generic_detail_list':
   case 'mql_detail_list':
   case 'sql_detail_list':
     compiledQuery = compileGenericDetailList(params);
     break;
   ```

4. **Update Validation** (`validateTemplateSelection`):
   - Add `generic_detail_list` to `templatesWithoutDateRange` array (supports optional dateRange for "all time" queries)

5. **Update Result Mapping** (`ExploreResults.tsx`):
   - Check for metric-specific date column names: `mql_date`, `sql_date`, `contacted_date`, `prospect_date`, `sqo_date`, `joined_date`

**Key Points:**
- `generic_detail_list` works for ALL volume metrics (MQLs, SQLs, Contacted, Prospects, SQOs, Joined)
- Automatically uses correct date field and filter based on metric parameter
- Supports optional dateRange (for "all time" queries)
- Uses DATE() conversion for type consistency
- Returns columns in DetailRecord-compatible format

**Files Modified:**
- `src/lib/semantic-layer/query-templates.ts` - Add template definition
- `src/lib/semantic-layer/query-compiler.ts` - Add compiler function and switch case
- `src/components/dashboard/ExploreResults.tsx` - Update result mapping for metric-specific date columns

**Reference Fix:**
- **MQL Drilldown (Fixed: January 16, 2026)**: Created `generic_detail_list` template and `compileGenericDetailList()` function to support MQL detail lists. Previously, drilldown tried to use `sqo_detail_list` which filtered by SQO-specific fields and returned no results for MQLs.

### CRITICAL: Date Comparison Consistency for Metrics (Fixed: January 16, 2026)

**‚ö†Ô∏è CRITICAL**: Always use `DATE()` conversion for date comparisons in metric SQL definitions, even when the field is TIMESTAMP type.

**Why**: `DATE()` ensures consistent date comparisons and includes the full day. `TIMESTAMP()` comparisons can exclude records due to time component mismatches, causing count discrepancies between metric queries and drilldown queries.

**Pattern**:
- ‚úÖ CORRECT: `DATE(v.Date_Became_SQO__c) >= DATE(@startDate) AND DATE(v.Date_Became_SQO__c) <= DATE(@endDate)`
- ‚ùå WRONG: `TIMESTAMP(v.Date_Became_SQO__c) >= TIMESTAMP(@startDate) AND TIMESTAMP(v.Date_Became_SQO__c) <= TIMESTAMP(@endDate)`

**Example**: SQO metric definition uses DATE() conversion:
```typescript
sql: `SUM(
  CASE 
    WHEN v.Date_Became_SQO__c IS NOT NULL
      AND DATE(v.Date_Became_SQO__c) >= DATE(@startDate) 
      AND DATE(v.Date_Became_SQO__c) <= DATE(@endDate)
      ...
  END
)`
```

**Matching Drilldown Queries**: Drilldown queries (sqo_detail_list, generic_detail_list) MUST use the same DATE() conversion pattern to ensure counts match between metric queries and drilldown queries.

**No Redundant WHERE Clause Date Filters**: DO NOT add date filters to WHERE clause for metrics that already filter in CASE statement. Metric SQL definitions already include date range checks in their CASE statements. Adding WHERE clause date filters causes double filtering and count discrepancies.

**Reference Fix:**
- **SQO Count Discrepancy (Fixed: January 16, 2026)**: Changed SQO metric definition from TIMESTAMP() to DATE() conversion for date comparisons. Removed redundant WHERE clause date filters in compileSingleMetric(). Updated sqo_detail_list to use DATE() conversion for consistency. This ensures metric queries and drilldown queries return matching counts (20 SQOs this quarter).

---

## Recruiter Security Rules

### Overview

Recruiters are external users who should only access their own client data via `/api/recruiter-hub`. All other dashboard data is restricted.

### Default-Deny Architecture

- **Middleware blocks recruiters** from all `/api/*` routes except an explicit allowlist
- **Defense-in-depth**: Route-level checks provide secondary protection
- **Data filtering**: Use `permissions.recruiterFilter` to filter data by agency

### Allowlisted Routes for Recruiters

```
/api/auth*                           - Authentication
/api/recruiter-hub*                  - Recruiter-specific endpoints
/api/users/me/change-password        - Password management
/api/dashboard/data-freshness        - Data freshness indicator
/api/dashboard/record-detail         - Record detail modal (has built-in agency filtering)
```

### Adding New API Routes - CRITICAL

When creating new API routes, you MUST decide:

1. **Recruiter-accessible route** (e.g., `/api/recruiter-hub/*`):
   - Add to middleware allowlist if not under `/api/recruiter-hub`
   - Use `permissions.recruiterFilter` to filter data by agency
   - Never trust client-supplied agency filters

2. **Non-recruiter route** (default):
   - Add `forbidRecruiter(permissions)` check after session validation:
   ```typescript
   import { getSessionPermissions } from '@/types/auth';
   import { forbidRecruiter } from '@/lib/api-authz';

   // After session check:
   const permissions = getSessionPermissions(session);  // NO DB query!
   if (!permissions) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
   
   const forbidden = forbidRecruiter(permissions);
   if (forbidden) return forbidden;
   ```

### Key Files

| File | Purpose |
|------|---------|
| `src/middleware.ts` | Default-deny pattern, recruiter allowlist |
| `src/lib/api-authz.ts` | `forbidRecruiter()` helper function |
| `src/types/auth.ts` | `getSessionPermissions()` extracts permissions from session (NO DB query) |
| `src/lib/permissions.ts` | `getPermissionsFromToken()` (used by session callback), `getUserPermissions()` (legacy, queries DB) |

### Pattern: Route-Level Recruiter Block

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { getSessionPermissions } from '@/types/auth';
import { forbidRecruiter } from '@/lib/api-authz';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get permissions from session (NO DB query!)
    const permissions = getSessionPermissions(session);
    if (!permissions) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Block recruiters from this route
    const forbidden = forbidRecruiter(permissions);
    if (forbidden) return forbidden;

    // Use permissions.userId instead of querying User table
    const userId = permissions.userId;

    // ... rest of handler
  } catch (error) {
    // ... error handling
  }
}
```

### Pattern: Recruiter Data Filtering

```typescript
// For recruiter-accessible routes, filter by agency
const permissions = getSessionPermissions(session);  // NO DB query!

if (permissions?.role === 'recruiter' && permissions.recruiterFilter) {
  // Add agency filter to query
  whereClause.externalAgency = permissions.recruiterFilter;  // recruiterFilter is the agency name string
}
```

### Common Pitfalls - Recruiter Security

#### ‚ùå Trusting Client-Supplied Agency Filters
- **WRONG**: `const agencyId = request.query.agencyId;`
- **RIGHT**: `const agencyId = permissions.recruiterFilter?.agencyId;`
- **WHY**: Client can manipulate query params to access other agencies' data

#### ‚ùå Forgetting Route-Level Checks
- **WRONG**: Relying only on middleware allowlist
- **RIGHT**: Add `forbidRecruiter()` check in route handler
- **WHY**: Defense-in-depth protects against middleware bypass

#### ‚ùå Not Blocking New Routes
- **WRONG**: Creating new API route without considering recruiter access
- **RIGHT**: Default to blocking with `forbidRecruiter()`, explicitly allow if needed
- **WHY**: Fail-secure prevents accidental data exposure

### Routes That Block Recruiters

These routes use `forbidRecruiter()` for defense-in-depth:

- `/api/games/*` - Pipeline Catcher game
- `/api/explore/*` - AI-powered exploration
- `/api/saved-reports/*` - Custom report management
- `/api/sga-hub/*` - SGA tracking features
- `/api/dashboard/*` (except data-freshness, record-detail) - Main dashboard APIs

### Testing Recruiter Security

1. **Create test recruiter user** with role='recruiter' and agency assignment
2. **Test middleware blocking**: Verify 403 on non-allowlisted routes
3. **Test data filtering**: Verify recruiter only sees their agency's data
4. **Test route-level blocks**: Verify `forbidRecruiter()` returns 403
5. **Test bypasses**: Try accessing other agencies via query params (should fail)
