'use strict';
/**
 * generate-model-inventory.cjs
 * Parses prisma/schema.prisma and produces docs/_generated/prisma-models.md
 * Run with: node scripts/generate-model-inventory.cjs
 */

const fs = require('fs');
const path = require('path');

const PROJECT_ROOT = path.join(__dirname, '..');
const SCHEMA_FILE = path.join(PROJECT_ROOT, 'prisma', 'schema.prisma');
const OUTPUT_FILE = path.join(PROJECT_ROOT, 'docs', '_generated', 'prisma-models.md');

/** Parse all model blocks from a Prisma schema string */
function parseModels(schemaContent) {
  const models = [];
  const lines = schemaContent.split('\n');
  let currentModel = null;

  for (const line of lines) {
    // Detect model block start
    const modelMatch = line.match(/^model\s+(\w+)\s*\{/);
    if (modelMatch) {
      currentModel = {
        name: modelMatch[1],
        fields: [],
        mapTo: null,
      };
      continue;
    }

    // Detect model block end (closing brace at column 0)
    if (currentModel && /^\}/.test(line)) {
      models.push(currentModel);
      currentModel = null;
      continue;
    }

    if (!currentModel) continue;

    const trimmed = line.trim();

    // Skip empty lines and comment-only lines
    if (!trimmed || trimmed.startsWith('//')) continue;

    // @@map block attribute — captures the mapped table name
    if (trimmed.startsWith('@@map(')) {
      const mapMatch = trimmed.match(/@@map\("([^"]+)"\)/);
      if (mapMatch) currentModel.mapTo = mapMatch[1];
      continue;
    }

    // Other block attributes (@@unique, @@index, etc.) — skip
    if (trimmed.startsWith('@@')) continue;

    // Field definition — strip inline comment first
    const lineNoComment = trimmed.replace(/\/\/.*$/, '').trim();
    if (!lineNoComment) continue;

    const tokens = lineNoComment.split(/\s+/);
    if (tokens.length < 2) continue;

    const fieldName = tokens[0];
    const fieldType = tokens[1];

    // Build notes array
    const notes = [];

    if (/@id\b/.test(lineNoComment)) notes.push('@id');
    if (/@unique\b/.test(lineNoComment)) notes.push('@unique');
    if (/@updatedAt\b/.test(lineNoComment)) notes.push('@updatedAt');

    // Handle nested parens in @default(cuid()) and @default(now())
    const defaultMatch = lineNoComment.match(/@default\(([^()]*(?:\([^()]*\))?[^()]*)\)/);
    if (defaultMatch) notes.push(`default(${defaultMatch[1]})`);

    if (/@relation\b/.test(lineNoComment)) notes.push('relation');

    // db. type annotation
    const dbMatch = lineNoComment.match(/@db\.(\w+)/);
    if (dbMatch) notes.push(`db.${dbMatch[1]}`);

    if (fieldType.endsWith('?')) notes.push('nullable');
    if (fieldType.endsWith('[]')) notes.push('list');

    currentModel.fields.push({
      name: fieldName,
      type: fieldType,
      notes: notes.join(', '),
    });
  }

  return models;
}

// ── Main ────────────────────────────────────────────────────────────────────

const schemaContent = fs.readFileSync(SCHEMA_FILE, 'utf8');
const models = parseModels(schemaContent);

// Build markdown output
const now = new Date().toISOString().replace('T', ' ').slice(0, 19);
const totalModels = models.length;

let md = `# Prisma Models Inventory (Auto-Generated)\n\n`;
md += `> This file is auto-generated by \`npm run gen:models\`. Do not edit manually.\n`;
md += `> Generated: ${now}\n`;
md += `> Total: ${totalModels} models\n\n`;

for (const model of models) {
  const tableNote = model.mapTo ? ` → \`${model.mapTo}\`` : '';
  const fieldCount = model.fields.length;

  md += `## ${model.name}\n\n`;
  md += `- **Table**: \`${model.mapTo || model.name}\`${tableNote ? ' (mapped)' : ''}\n`;
  md += `- **Fields**: ${fieldCount}\n\n`;

  md += `| Field | Type | Notes |\n`;
  md += `|-------|------|-------|\n`;

  for (const field of model.fields) {
    const notes = field.notes || '';
    md += `| \`${field.name}\` | \`${field.type}\` | ${notes} |\n`;
  }

  md += '\n';
}

fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
fs.writeFileSync(OUTPUT_FILE, md, 'utf8');
console.log(`✓ Generated prisma-models.md: ${totalModels} models`);
